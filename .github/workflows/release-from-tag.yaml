name: Publish specification on tag (vX.Y / vX.Y.Z)

on:
  push:
    tags:
      - "v*.*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout this repository (the repo where the tag was created).
      #    - fetch-depth: 0 ensures full history + tags exist locally.
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) Parse the tag name and derive:
      #    - series: X.Y (used for release branch name release/X.Y)
      #    - folder: vX.Y (used for publication folder specification/vX.Y)
      #    - release_name: exactly the tag name (releases are named vX.Y or vX.Y.Z)
      #    This step also validates the tag format.
      - name: Determine versions from tag
        id: ver
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"   # e.g. v6.0 or v6.0.1

          if [[ ! "$TAG" =~ ^v([0-9]+)\.([0-9]+)(\.([0-9]+))?$ ]]; then
            echo "Unsupported tag format: $TAG (expected vX.Y or vX.Y.Z)"
            exit 1
          fi

          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"

          SERIES="${MAJOR}.${MINOR}"     # X.Y
          FOLDER="v${SERIES}"            # vX.Y
          RELEASE_NAME="$TAG"            # vX.Y or vX.Y.Z

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "series=$SERIES" >> "$GITHUB_OUTPUT"
          echo "folder=$FOLDER" >> "$GITHUB_OUTPUT"
          echo "release_name=$RELEASE_NAME" >> "$GITHUB_OUTPUT"
          echo "major=$MAJOR" >> "$GITHUB_OUTPUT"

      # 3) Ensure the release branch release/X.Y exists.
      #    - If it already exists on origin: do nothing.
      #    - If not: create it locally from the tag and push it to origin.
      - name: Create release branch if missing (simple git)
        run: |
          set -euo pipefail

          TAG="${{ steps.ver.outputs.tag }}"
          SERIES="${{ steps.ver.outputs.series }}"
          BRANCH="release/${SERIES}"

          # Ensure we have the commit behind the tag locally
          git fetch --tags --force

          # If branch exists on origin: do nothing
          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
            echo "Branch exists: $BRANCH"
            exit 0
          fi

          echo "Creating branch $BRANCH from tag $TAG"
          git branch "$BRANCH" "$TAG"
          git push origin "$BRANCH"

      # 4) Create an installation token for the publishing GitHub App.
      #    This token grants write access to the publication repo.
      - name: Create GitHub App installation token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.OOAPI_APP_PUBLISH_ID }}
          private-key: ${{ secrets.OOAPI_APP_PUBLISH_SECRET }}
          owner: open-education-api
          repositories: |
            open-education-api.github.io

      # 5) Checkout the publication repository into ./target
      #    so we can copy files into it and push changes.
      - name: Checkout publication repository (open-education-api.github.io)
        uses: actions/checkout@v4
        with:
          repository: open-education-api/open-education-api.github.io
          token: ${{ steps.app-token.outputs.token }}
          path: target

      # 6) Sync specification source to the publication repo.
      #
      #    Behaviour:
      #    - For major version 5: copy from ./v5/ (this is where v5 changes still happen today)
      #    - For all other versions: copy from ./source/
      #
      #    The v5 folder is expected to be phased out over time.
      - name: Sync specification -> publication repo (specification/vX.Y)
        run: |
          set -euo pipefail

          DEST="target/specification/${{ steps.ver.outputs.folder }}"

          if [[ "${{ steps.ver.outputs.major }}" == "5" ]]; then
            SRC="v5"
          else
            SRC="source"
          fi

          mkdir -p "$DEST"
          rsync -a --delete "${SRC}/" "${DEST}/"

      # 7) Commit and push only if there are changes in the publication repo.
      - name: Commit and push publication repo changes (if any)
        run: |
          set -euo pipefail
          cd target

          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "Publish specification for ${{ steps.ver.outputs.tag }} -> specification/${{ steps.ver.outputs.folder }}"
            git push
          else
            echo "No changes to publish."
          fi

      # 8) Bundle the OpenAPI specification into single-file outputs.
      #    - ooapi.yaml: bundled OpenAPI in YAML form
      #    - ooapi.json: bundled OpenAPI in JSON form
      #    Redocly determines the output format by the file extension (there is no --format flag).
      #
      #    Behaviour:
      #    - For v5 tags: bundle from v5/spec.yaml
      #    - For all other tags: bundle from source/spec.yaml
      - name: Bundle OpenAPI spec (release asset)
        run: |
          set -euo pipefail
          npm i -g @redocly/cli@1.34.2

          if [[ "${{ steps.ver.outputs.major }}" == "5" ]]; then
            SPEC="v5/spec.yaml"
          else
            SPEC="source/spec.yaml"
          fi

          redocly bundle "$SPEC" -o ooapi.yaml
          redocly bundle "$SPEC" -o ooapi.json

      # 9) Create a GitHub Release in THIS repo for the tag.
      #    - tag_name selects the existing tag
      #    - name sets the release title (equal to vX.Y or vX.Y.Z)
      #    - generate_release_notes lets GitHub produce notes automatically
      - name: Create GitHub Release for this tag (with assets)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.tag }}
          name: ${{ steps.ver.outputs.release_name }}
          generate_release_notes: true
          files: |
            ooapi.yaml
            ooapi.json
